# 07、请求流程

## 使用 IP 请求 Web 服务器

在浏览器中输入 http://127.0.0.1/ 用 Wireshark 抓包，获得如下的信息

![](https://raw.githubusercontent.com/dddygin/image-storage/main/blog/image/network/http/01/08_01.png)

### 抓包分析

从图中看出，浏览器的端口是"52085", 服务器使用的端口是 80。

- 从输入的连接中获取 IP 和 端口；
  - IP 和端口是定位请求资源的位置。

- TCP 三层握手；
  - HTTP 是 TCP 上层协议，所以 HTTP 要按照 TCP 协议的规范，而浏览器是发出的请求是跑在 HTTP 协议上的，所以也需要使用 TCP “三次握手”建立与 Web 服务器的连接；
  - 浏览器 --> SYN --> 服务器，服务器 --> SYN/ACK --> 浏览器，浏览器 --> SYN --> 服务器 **（前三个包）**。
- 成功建立起连接TCP通道，HTTP协议开始工作；
  - 浏览器按照 HTTP 协议规定的格式，通过 TCP 发送了一个“GET / HTTP/1.1”请求报文 **（第四个包）；**
  - Web 服务器通过 TCP 协议层面，回复收到第四个包的请求信息（不过这个 TCP 包 HTTP 协议是看不见的）**（第五个包）；
  - Web 服务器收到服务器的 HTTP 请求，需要对请求的报文进行解析，看看要请求什么，根据不同的请求内容，将响应的内容包装成 HTTP 格式的报文发回去 **（第六个包）；
  - 浏览器在收到方法返回的报文后，也需要给服务器一个 TCP 层面的确认（ACK）的信息 **（第七个包）。**
- 获得响应的报文，解析报文，渲染页面；
- 这之后还有两个来回，共四个包，重复了相同的步骤。这是浏览器自动请求了作为网站图标的“favicon.ico”文件，与我们输入的网址无关。但因为我们的实验环境没有这个文件，所以服务器在硬盘上找不到，返回了一个“404 Not Found”。**（第 8-11 个包）**。

以下是请求的交互图

![](https://raw.githubusercontent.com/dddygin/image-storage/main/blog/image/network/http/01/08_02.png)

总结一下浏览器 HTTP 请求过程：

1. 浏览器从地址栏的输入中获得服务器的 IP 地址和端口号；
2. 浏览器用 TCP 的三次握手与服务器建立连接；
3. 浏览器向服务器发送拼好的报文；
4. 服务器收到报文后处理请求，同样拼好报文再发给浏览器；
5. 浏览器解析报文，渲染输出页面。

## 使用域名请求 Web 服务器

使用域名请求资源和 IP 请求最大的问题就是，域名是如何找到对应服务的的 IP ，其他后面的操作都是一样的。

> 我们在 host 文件中配置了 www.chrono.com  127.0.0.1

输入域名和 IP 抓取到的报文是一样的，但是我们输入的是域名，而在抓取的包中显示的是 127.0.0.1，这个是如何转换的呢？

答案是DNS，通过访问一系列的域名解析服务器，试图把这个域名翻译成 TCP/IP 协议里的 IP 地址。

### DNS 解析流程

- 浏览器输入域名请求资源
- 浏览器知道输入的不是 IP 需要对域名进行解析
  1. 首先，浏览器先看一下自己是否有缓存该域名解析，有就返回 IP;
  2. 如果浏览器没有缓存,就查询操作系统的缓存（host 文件），如果有就返回IP；
  3. 如果也没有，就需要向本地 DNS、根 DNS、顶级 DNS、权威 DNS 层层解析当然这中间有缓存，可能不会费太多时间就能拿到结果。
- 在DNS 解析可能会给出 CDN 服务器的 IP 地址；
  - 这样你拿到的就会是 CDN 服务器而不是目标网站的实际地址；
  - 因为 CDN 会缓存网站的大部分资源，比如图片、CSS 样式表，所以有的 HTTP 请求就不需要再发到 目标服务器，CDN 就可以直接响应你的请求，把数据发给你；
  - 由 PHP、Java 等后台服务动态生成的页面属于“动态资源”，CDN 无法缓存，只能从目标网站获取。于是你发出的 HTTP 请求就要开始在互联网上的“漫长跋涉”，经过无数的路由器、网关、代理，最后到达目的地。
- 如果拿到了 IP 就 开始 TCP 三次握手；
- 如果拿不到最终失败的进入错误页面。

> 为什么每一级需要缓存域名？
>
> 因为域名解析的全过程实在是太复杂了，如果每一个域名都要大费周折地去网上查一下，那我们上网肯定会慢得受不了.

当然，在真实的网络环境中会更复杂，**在DNS 解析可能会给出 CDN 服务器的 IP 地址，这样你拿到的就会是 CDN 服务器而不是目标网站的实际地址**。因为 CDN 会缓存网站的大部分资源，比如图片、CSS 样式表，所以有的 HTTP 请求就不需要再发到 Apple，CDN 就可以直接响应你的请求，把数据发给你

## 如何请求资源

获取到 IP 在建立好三次握手之后就可请求资源了。目标网站的服务器对外表现的是一个 IP 地址，但为了能够扛住高并发在内部也是一套复杂的架构。基本流程图如下图：

![](https://raw.githubusercontent.com/dddygin/image-storage/main/blog/image/network/http/01/08_03.png)

- 在入口是负载均衡设备（集群）；
  - 例如四层的 LVS 或者七层的 Nginx。
- 负载均衡设备会先访问系统里的缓存服务器
  - 如有 memory 级缓存 Redis 和 disk 级缓存 Varnish
  - 们的作用与 CDN 类似，不过是工作在内部网络里，把最频繁访问的数据缓存几秒钟或几分钟，减轻后端应用服务器的压力
- 如果没有，再访问应用服务器
  - Java 的 Tomcat/Netty/Jetty
  - Python 的 Django，还有 PHP、Node.js、Golang 等等
- 如果没有再访问后面的 MySQL、PostgreSQL、MongoDB 等数据库服务等等
- 应用服务器的输出到了负载均衡设备这里，请求的处理就算是完成了
  - 就要按照原路再走回去，还是要经过许多的路由器、网关、代理。如果这个资源允许缓存
  - 过 CDN 的时候它也会做缓存，这样下次同样的请求就不会到达源站了。
- 最后网站的响应数据回到了你的设备
  - 它可能是 HTML、JSON、图片或者其他格式的数据，需要由浏览器解析处理才能显示出来；
  - 如果数据里面还有超链接，指向别的资源，那么就又要重走一遍整个流程，直到所有的资源都下载完。

## 小结

1. HTTP 协议基于底层的 TCP/IP 协议，所以必须要用 IP 地址建立连接；
2. 如果不知道 IP 地址，就要用 DNS 协议去解析得到 IP 地址，否则就会连接失败
3. 建立 TCP 连接后会顺序收发数据，请求方和应答方都必须依据 HTTP 规范构建和解析报文；
4. 为了减少响应时间，整个过程中的每一个环节都会有缓存，能够实现“短路”操作；
5. 虽然现实中的 HTTP 传输过程非常复杂，但理论上仍然可以简化成实验里的“两点”模型。

