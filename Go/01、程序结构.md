# 程序结构

## 命名

Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名都遵循以下命名规则

### 命名规则

- 一个名字必须以一个字母（Unicode字母）或下划线开头
- 由任意数量的字母、数字、下划线组成
- 区分大小写

### 关键字

25个关键字

```go
break      default       func     interface   select
case       defer         go       map         struct
chan       else          goto     package     switch
const      fallthrough   if       range       type
continue   for           import   return      var
```

30多个预定义的名字

```go
内建常量: true false iota nil

内建类型: int int8 int16 int32 int64
          uint uint8 uint16 uint32 uint64 uintptr
          float32 float64 complex128 complex64
          bool byte rune string error

内建函数: make len cap new append copy close delete
          complex real imag
          panic recover
```

**作用域**

- 一个名字是在函数内部定义，那么它就只在函数内部有效；
- 如果是在函数外部定义，那么将在当前包的所有文件中都可以访问；
- 名字的开头字母的大小写决定了名字在包外的可见性
  - 大写开头，包外可见
  - 小写开头，包内可见

### 规范

- 包名一般用小写字母
- 变量名用<font color='orange'>驼峰式</font>命名
  - 正确正确：htmlEscape、HTMLEscape、escapeHTML、studentName
  - 错误示范：escapeHtml
- 变量名尽可能用短小的名字，当然，如果一个名字的作用域比较大，生命周期也比较长，那么用长的名字将会更有意义。

## 声明

Go语言主要有四种类型的声明语句：`var`、`const`、`type`和`func`，分别对应变量、常量、类型和函数实体对象的声明。

- 函数内部的名字则必须先声明之后才能使用

## 变量

### var

```go
var 变量名字 类型 = 表达式
```

其中，“类型” 和 “= 表达式” 两个部分可以省略其中一个。

- 省略 “类型” ，通过 “表达式” 的类型进行推断
- 省略 “= 表达式”，将用零值初始化该变量

#### 初始化时机

在<font color='orange'>包级别声明的变量</font>会在main入口函数执行前完成初始化，<font color='orange'>局部变量</font>将在声明语句被执行到的时候完成初始化

#### 零值

- 数值类型 -> `0`
- `bool` ->  `false`
- `string` ->  `""`
- 接口或引用类型  -> `nil`
- 数组或结构体等聚合类型 -> 每个元素或字段都是对应该类型的零值

<font color='orange'>Go语言中不存在未初始化的变量。</font>

#### 简短变量声明

在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。

- 用与局部变量的声明并赋值
- 支持组声明 ` a , b := 1,ture`
- 组简短变量声明中至少有一个变量是未声明过的

<font color='orange'>“:=”是一个变量声明语句，而“=”是一个变量赋值操作</font>

#### 指针

值 -> 指针 : `p := &x`

指针 -> 值：`*p`

```go
x := 1
p := &x         // p, of type *int, points to x
fmt.Println(*p) // "1"
*p = 2          // equivalent to x = 2
fmt.Println(x)  // "2"
```

- 零值：`nil`
- 相等：指向同一个变量或者全部是`nil` 才相等

#### new 函数

表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为`*T`

#### 变量的生命周期

- 包一级声明的变量，它的生命周期和整个程序的运行周期是一致的
- 局部变量的生命周期则是动态的，每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收

Go 语言的自动垃圾收集器实现思路：从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。

**因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。**

变量被编译器会自动选择在栈上还是在堆上分配局部变量的存储空间

- 如果变量逃逸了就在堆上分配
- 如果变量未逃逸，默认是在栈上分配内存，也可以在堆上

```go
var global *int

func f() {
    var x int
    x = 1
    global = &x
}

func g() {
    y := new(int)
    *y = 1
}
```

- f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。
- 相反，当g函数返回时，变量`*y`将是不可达的，也就是说可以马上被回收的。因此，`*y`并没有从函数g中逃逸，编译器可以选择在栈上分配`*y`的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间）

## 赋值

`++`递增和`--`递减语句（<font color='orange'>自增和自减是语句，而不是表达式</font>，因此`x = i++`之类的表达式是错误的）

```java
v := 1
v++    // 等价方式 v = v + 1；v 变成 2
v--    // 等价方式 v = v - 1；v 变成 1
```

##### 元组赋值

```go
x,y = x,y // 交换 x y 值
```

##### 可赋值型

赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量也会产生赋值行为。

## 类型

一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的.

```go
type 类型名字 底层类型
```

```go
type Celsius float64    // 摄氏温度
type Fahrenheit float64 // 华氏温度
```

它们虽然有着相同的底层类型float64，但是它们是不同的数据类型，因此它们不可以被相互比较或混在一个表达式运算.

显式转换`T(t)`, T 的底层类型和 t 的底层类型必须式可以相互转换的,如 T 的底层类型式 float64, 而 `t`的底层类型可以是 float32,(有可能会失去精度),但是不会报错,如果`t` 的底层类型是 `string` 则编译都通不过.

## 包和文件

- 首字母大写，包内外可见，首字母小写，包内可见
- 首字是中/日/韩文，默认是包内可见

##### 包的初始化

- `import` 中的顺序是影响包加载的顺序
- 包初始化的时候会调用`init()` 方法
- 在包初始化后和`init()`方法初始化后才会初始化`main()`

初始化顺序

import（自上而下） -> `init()` -> `main()`

## 作用域

与 Java 语法总体类似，就是属性或者方法的首字母大小写对应 Java 中的 `public` 和 `default`





