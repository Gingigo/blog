# 01 | 为什么需要消息队列？

**什么是消息队列**？

- 消息：是两台计算机间传送的数据单位。
- 队列：是消息的传输过程中保存消息的容器。 
- 消息队列：就是两条计算机相互通信的消息，通过队列容器进行传输的中间件。

### 消息队列应用场景

#### 1、异步处理

例如，**在秒杀系统中**，秒杀系统需要解决的核心问题是:如何利用有限的资源，尽可能地处理短时间海量请求。一个秒杀系统基本地步骤是：

- 风险控制；
- 库存锁定；
- 生产订单；
- 短信通知；
- 更新统计数据。

> 如果没有任何优化，正常地处理流程，App将请求发送给网关，依次调用上述 5个流程，然后返回给 App。

其实，能否决定秒杀成功，实际上只有风险控制和库存锁定这 2 个步骤。只要用户的秒杀请求通过风控请求并且在服务端完成库存锁定，就可以给用户返回秒杀结构，后续的生成的订单、短信通知和更新统计等步骤，并不需要在秒杀处理请求中处理完成。所以我们可以设计如图 1的架构。

![](https://raw.githubusercontent.com/dddygin/image-storage/main/blog/image/middleware/mq/mq-master/mq-master-01-01.png)

<center>图 1 消息队列应用于秒杀系统</center>
我们可以看出，处理一个秒杀请求，从5 个步骤减少为 2 个步骤，这样响应不仅快，而且在秒杀期间，我们可以把更多的服务器资源用来处理秒杀请求。秒杀结束之后再把资源用于处理后面的步骤，充分利用有限的服务器资源处理更多的秒杀请求

**这个场景中，消息队列被用于实现服务器的异步请求处理**，这样做的好处：

- 可以更快的返回结果，减少等待；
- 自然实现了步骤间的并发，提升系统总体的性能。

#### 2、流量控制

##### 消息队列控制流量

我们已经用消息队列实现了部分工作的异步处理，提升了秒杀系统的性能。但是我们还有一个问题：**如何避免过多的请求压垮我们的秒杀系统？**

当秒杀开始的时候，海量的请求通过网关直接后端应用，这样很容易被打挂掉，所以我们应该设计一个健壮性的程序，有自我保护的能力。

因此，**我们的设计思路是，使用消息队列隔离网关和后端服务，以达到流量控制和保护后端服务的目的**。

加入消息队列后，整个秒杀流程变为：

1. 网关在收到请求后，将请求放入请求消息队列；
2. 后端服务从请求消息队列中获取 APP 请求，完成后续秒杀处理过程，然后返回结果。

  ![](https://raw.githubusercontent.com/dddygin/image-storage/main/blog/image/middleware/mq/mq-master/mq-master-01-02.png)

<center>图2 消息队列控制秒杀系统流量</center>
基本步骤如下：

1. 秒杀开始后，短时间内大量的秒杀请求到达网关时，不会直接冲击到后端的秒杀服务，而是先堆积在消息队列中。
2. 后端服务按照自己最大的处理能力，从消息队列中消费请求进行处理。
3. 对于超时的请求可以直接丢弃，App 将超时无响应的请求处理为秒杀失败即可。

这种设计的优点：能根据下游的处理能力自动调节流量，达到“削峰填谷”的作用。但是这样做的也是有代价的：

- 增加了系统调用链环节，导致总体的响应时延变长。
- 上下游系统都要将同步调用改为异步消息，增加了系统的复杂度。

##### 其他方法：令牌桶控制流量

**什么是令牌桶原理？**

令牌桶控制流量的原理是：单位时间内只发放固定数量的令牌到令牌桶中，规定服务在处理请求之前必须在令牌桶中拿到一个令牌，如果令牌桶中没有令牌，则拒绝请求。这样就保证了单位时间内，能处理的请求不超过发放令牌桶的数据量，起到了流量控制的作用。

![](https://raw.githubusercontent.com/dddygin/image-storage/main/blog/image/middleware/mq/mq-master/mq-master-01-03.png)

<center>图 3 令牌桶控制流量</center>
**如何实现令牌桶？**

令牌桶可以是一个简单的有固定容量的消息队列加一个“令牌发生器”来实现：令牌发生器按照预估的处理能力，均速产生令牌并放入令牌队列(如果队列满了则丢弃令牌)，网关在收到请求时去令牌桶消费一个令牌，获取到令牌则继续调用后端的服务，如果获取不到令牌则直接返回秒杀失败。

#### 3、服务解耦

**消息队列的另外一个作用，就是实现系统应用之间的解耦**。 再举一个电商的例子来说明解耦的作用和必要性。 

我们知道订单是电商系统中比较核心的数据，当一个订单创建时：

1. 支付系统需要发起支付流程；
2. 风控系统需要审核订单的合法性；
3. 客服系统需要给用户发短信告知用户；
4. 经营分析系统需要更新统计数据；
5. ...

这些订单下游的系统都需要实时获得订单数据。随着业务不断发展，这些订单下游系统不断的增加，不断变化，并且每个系统可能只需要订单数据的一个子集，负责订单服务的开发团队不得不花费很大的精力，应对不断增加变化的下游系统，不停地修改调试订单系统与这些下游系统的接口。**任何一个下游系统接口变更，都需要订单模块重新进行一次上线，对于一个电商的核心服务来说，这几乎是不可接受的**。 (耦合度高)

所有的电商都选择用消息队列来解决类似的系统耦合过于紧密的问题。引入消息队列后，订单服务在订单变化时发送一条消息到消息队列的一个主题 Order 中，所有下游系统都订阅主题 Order，这样每个下游系统都可以获得一份实时完整的订单数据。 

无论增加、减少下游系统或是下游系统需求如何变化，订单服务都无需做任何更改，实现了订单服务与下游服务的解耦。

### 小结

消息队列最常被使用的三种场景：异步处理、流量控制和服务解耦。当然，消息队列的适用范围不仅仅局限于这些场景，还有包括： 

- 作为发布/订阅系统实现一个微服务级系统间的观察者模式；
- 连接流计算任务和数据；
- 用于将消息广播给大量接收者。

**我们在单体应用里面需要用队列解决的问题，在分布式系统中大多都可以用消息队列来解决。** 

**消息队列也有它自身的一些问题和局限性 ：**

- 引入消息队列带来的延迟问题；
- 增加了系统的复杂度；
- 可能产生数据不一致的问题。