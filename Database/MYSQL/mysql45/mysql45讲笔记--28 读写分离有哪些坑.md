读写分离有哪些坑？

### 读写分离两种架构

- 客户端直连数据库（结构详情如图 1）

  ![](https://raw.githubusercontent.com/dddygin/image-storage/main/blog/image/database/mysql/mysql45/mysql45-28-01.png)

  <center>图 1 直连读写分离结构</center>
  - 如何实现：
    - 可以同过  AOP 指定数据库
    
    - zookeeper 等
    
  - 优缺点：
    
    - 优点：
      1.  少了一层 proxy 转发，所以查询性能稍微好一点；
      2. 架构简单，排查问题方便，关注业务逻辑开发。
    - 缺点：
      1. 耦合度高，如果出现主备切换或库迁移，需要调整数据库连接信息。
    
      

- 客户端通过 proxy 连接数据库

  ![](https://raw.githubusercontent.com/dddygin/image-storage/main/blog/image/database/mysql/mysql45/mysql45-28-02.png)

  <center>图 2 带 proxy 的读写分离架构</center>
  - 实现方式：
    - mycat、sharding-sphere
  - 优缺点：
    - 优点：
      1.  对客户端比较友好，不需要关注后端细节、连接维护等；
      2. 耦合度低，方便扩展。
    - 缺点：
      1. 整体架构复杂

其实以上这两种架构都存在一个问题。由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询的是从库的话，就有可能读到刚刚的事务更新之前的状态。

**我们暂且定义一个概念，如果”在从库上读到系统的一个过期状态“，我们称为过期读**

### 如何解决过期读？

- 强制走主库方案
- sleep 方案
- 判读主备无延迟方案
- 配合 semi-sync 方案
- 等主库点位方案
- 等 GTID 方案

#### 强制走主库方案

**核心原理**：

1. 对于必须拿到最新结果的请求，强制将其发到主库上。比如交易类业务。
2. 对于可以读到旧数据请求，才将其发到从库上。比如商品的展示，晚几秒钟也没事。

**局限性**：

1. **不适合实时性强的业务**。如果碰到”所有查询都不能是过期读“的需求，比如金融类业务

#### sleep 方案

**核心原理**：主库更新后，读从库之前先 sleep 一下。具体方案类似执行 select sleep(1)命令。

**局限性**：

1. 这个方案适合主从延迟靠近 1 秒的业务，很大概率能拿到更新的数据；

2. 如果这个查询请求本来 0.5s 就可以返回，确要等到 1s 返回；

3. 如果这个查询请求超过 1s ，这样就还是会参数过期读。



#### 判读主备无延迟方案

- **方法一：seconds_behind_master**
  - **核心原理**：在从库中执行 `show slave status`,拿到 <font color='orange'>seconds_behind_master</font> 参数，来判读主从延迟秒数，如果 <font color='orange'>seconds_behind_master = 0</font> ，就可以执行查询请求。
- **方法二： 对比位点确保主备无延迟 **
  - **核心原理：**
    - Master_Log_File 和 Read_Master_Log_Pos，表示的是读到的主库的最新位点 ；
    - Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是备库执行的最新位点 
    - 如果 Master_Log_File 和 Relay_Master_Log_File、Read_Master_Log_Pos 和 Exec_Master_Log_Pos 这两组值完全相同，就表示接收到的日志已经同步完成
- **方法三：对比 GTID 集合**
  - **核心原理：**
    - Auto_Position = 1,表示主备关系使用GTID协议
    - Retrieved_Gtid_Set,是备库收到的所有日志的 GTID 集合 
    - Executed_Gtid_Set，是备库所有已经执行完成的 GTID 集合
    - 如果这个两个集合相同，也就表示备库收到的日志都已经同步完成了

我们上面判断主备无延迟的逻辑，是“备库收到的日志都执行完成了”。但是，从 binlog 在主备之间状态的分析中，不难看出还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日志的状态。

##### 配合 semi-sync

要解决这个问题，就要引入半同步复制，也就是 semi-sync replication。

 semi-sync 做了这样的设计 ：

1.  事务提交的时候，主库把 binlog 发给从库； 
2. 从库收到 binlog 以后，发回给主库一个 ack，表示收到了； 
3. 主库收到这个 ack 以后，才能给客户端返回“事务完成”的确认。

**优点**：

1. 能防止主库掉电导致数据丢失。
2. 能解决一主一备下的主备延迟导致查询问题。

**局限性：**

1. 如果查询是落在这个响应了 ack 的从库上，是能够确保读到最新数据； 但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题。（**只能用于”一主一备“**） 
2.  判断同步位点的方案还有另外一个潜在的问题 ,如果在业务更新的高峰期，主库的位点或者 GTID 集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况。（**主库更新快，导致主从无法同步**）

​	

#### 等主库位点方案

**命令 `select master_pos_wait(file, pos[, timeout]);`**

1.  它是在从库执行的
2.  参数 file 和 pos 指的是主库上的文件名和位置 
3.  timeout 可选，设置为正整数 N 表示这个函数最多等待 N 秒 
4. 返回的信息：
   1.  如果执行期间，备库同步线程发生异常，则返回 NULL 
   2.  如果等待超过 N 秒，就返回 -1； 
   3.  如果刚开始执行的时候，就发现已经执行过这个位置了，则返回 0。 

**核心思想**：

1. 在主库执行完事务后， 马上执行 show master status 得到当前主库执行到的 File 和 Position； 
2.  选定一个从库执行查询语句； 
3.  在从库上执行 select master_pos_wait(File, Position, 1)； 
4.  如果返回值是 >=0 的正整数，则在这个从库执行查询语句； 
5.  否则，到主库执行查询语句 。

按照我们设定不允许过期读的要求，就只有两种选择，一种是超时放弃，一种是转到主库查询。具体怎么选择，就需要业务开发同学做好限流策略了。

#### GTID 方案

``` mysql
select wait_for_executed_gtid_set(gtid_set, 1);
```

 这条命令的逻辑是： 

1.  等待，直到这个库执行的事务中包含传入的 gtid_set，返回 0； 
2.  超时返回 1。 

**核心思想：**

1.  trx1 事务更新完成后，从返回包直接获取这个事务的 GTID，记为 gtid1； 
2.  选定一个从库执行查询语句； 
3.  在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)； 
4.  如果返回值是 0，则在这个从库执行查询语句； 
5.  否则，到主库执行查询语句。 

跟等主库位点的方案一样，等待超时后是否直接到主库查询，需要业务开发同学来做限流考虑。 

**总结**

其实，在实际应用中，这几个方案是可以混合使用的。

