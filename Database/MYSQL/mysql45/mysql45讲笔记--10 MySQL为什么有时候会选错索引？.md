# 10 | MySQL为什么有时候会选错索引？

我们知道在MySQL 中一张表其实是可以支持多个索引的，但是，你写SQL语句的时候，很少指定要使用那个索引的，我们第一课的时候有学过，要选择走那个索引是优化器的决定的，当然我们也可以通过 force index 来指定索引。那为什么MySQL 会选错索引呢？ 有什么解决方法？

### 优化器的逻辑

选择索引是优化器的工作。而优化器的目的就是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，**扫描行数是影响执行代价的因素之一**。扫描的行数越少，意味着访问磁盘的次数越少，消耗的CPU资源越少。

当然，扫描行数并不是唯一判断标准，优化器还会结合是否使用临时表、是否排序等因素综合判断。

#### 扫描行数是怎么判断的？

MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件地记录有多少条，而只能根据统计信息来估算记录数。

这个统计信息就是索引的“区分度”。显然，一个索引上不通过的值越多，这个索引的区分度就越好。而一个索引上不用的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。

##### 怎么得到索引的基数？

因为数据量大，所以采用的是“采样统计”。

采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。

在 MySQL 中，有两种存储索引统计的方式，可以通过设置参数 innodb_stats_persistent 的值来选择：

设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。

设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。

### 第一种情况：预计扫描行数偏差误导了优化器的

不走二级索引，这是因为，二级索引的预计扫描数量多（与实际偏差大），优化器认为二级索引都要回到主键索引上查出整行数据，这个代价优化器也要算进去的。而如果选择全扫描 ，是直接在主键索引上扫描的，没有额外的代价。优化器会估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快。

**解决方法:**

既然是统计信息不对，那就修正。analyze table t 命令，可以用来重新统计索引信息。然后再执行查询语句即可。

### 第二种情况：索引选择异常和处理

```mysql
mysql> select * from t where (a between 1 and 1000)  and (b between 50000 and 100000) order by b limit 1;
```

- 如果使用索引 a 进行查询，那么就是扫描索引 a 的前 1000 个值，然后取到对应的 id，再到主键索引上去查出每一行，然后根据字段 b 来过滤。显然这样需要扫描 1000 行。
- 如果使用索引 b 进行查询，那么就是扫描索引 b 的最后 50001 个值，与上面的执行过程相同，也是需要回到主键索引上取值再判断，所以需要扫描 50001 行。

结果优化器选择了第二种，选中了b索引。

解决方法：

1. 采用 force index 强行选择一个索引。就直接选择这个索引，不再评估其他索引的执行代价。
2. 我们可以考虑修改语句，引导 MySQL 使用我们期望的索引。“order by b limit 1” 改成 “order by b,a limit 1” ，语义的逻辑是相同的。
3. 我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引
