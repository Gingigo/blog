# 26、备库为什么会延迟好几个小时？

### 备库并行复制能力

**为什么主备会延迟好几个小时？**

除了上一篇文章说的原因外。其实还有一个原因，那就是备库并能复制能力。

产生原因：在主库上，影响并发度的原因就是各种锁了。由于 InnoDB 引擎支持行锁，除了所有并发事务都在更新同一行（热点行）这种极端场景外，它对业务并发度的支持还是很友好的。所以，你在性能测试的时候会发现，并发压测线程 32 就比单线程时，总体吞吐量高。而日志在备库上的执行，就是备库上 sql_thread 更新数据 的逻辑。如果是用单线程的话，就会导致备库应用日志不够快，造成主备延迟。说白了就是（**主库多线程，备库单线程**）

之后，MySQL 引入了备库并行复制能力，如图 1，将单线程 sql_thread 拆分成 多个 worker 执行。

![](https://raw.githubusercontent.com/dddygin/image-storage/main/blog/image/database/mysql/mysql45/mysql45-26-01.png)

<center>图 1 多线程模型</center>

MySQL 提供了一个参数用来设置 worker 的数量，slave_parallel_workers ，建议把这个值设置成 8~16 之间最好（32 核物理机的情况）

**事务能不能按照轮询的方式分发给各个 worker？**

答案是不可以，因为每个线程被 CPU 调度 是随机的，而事务执行时顺序的

**一个事务可否由多个worker 完成**

答案是不可以，因为这样破环了事务的隔离性，会导致数据错误

**coordinate 两个基本要求**

- 不能造成更新覆盖。这就要去更新同一行的两个事务，必须被分发到同一个 worker 中。
- 同一个事务不能被拆开，必须放到同一个 worker中。

各个版本的多线程复制，都遵循了这两条基本原则。接下来，我们就看看各个版本的并行复制策略。

### 5.6 版本之前

MySQL 只支持单线程复制，由此在主库并发高、TPS 高时就会出现严重的主备延迟问题。

需要自己改数据库源码，这里提供了两种思路：

1. 按表分发策略：按表分发事务的基本思路是，如果两个事务更新不同的表，它们就可以并行。因为数据是存储在表里的，所以按表分发，可以保证两个 worker 不会更新同一行
2. 按行分发策略：按行复制的核心思路是：如果两个事务没有更新相同的行，它们在备库上可以并行执行。显然，这个模式要求 binlog 格式必须是 row。

**相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资。源**这两个方案其实都有一些约束条件：

1. 要能够从 binlog 里面解析出表名、主键值和唯一索引的值。也就是说，主库的 binlog 格式必须是 row；
2. 表必须有主键；
3. 不能有外键。表上如果有外键，级联更新的行不会记录在 binlog 中，这样冲突检测就不准确。

### MySQL 5.6 版本的并行复制策略

官方 MySQL5.6 版本，支持了并行复制，只是支持的粒度是按库并行。

这个策略的并行效果，取决于压力模型。如果在主库上有多个 DB，并且各个 DB 的压力均衡，使用这个策略的效果会很好。

 相比于按表和按行分发，这个策略有两个优势： 

1.  构造 hash 值的时候很快，只需要库名 ；而且一个实例上 DB 数也不会很多，不会出现需要构造 100 万个项这种情况。
2.  不要求 binlog 的格式 ； 因为 statement 格式的 binlog 也可以很容易拿到库名。 

**缺点**

如果你的主库上的表都放在同一个 DB 里面，这个策略就没有效果了；或者如果不同 DB 的热点不同，比如一个是业务逻辑库，一个是系统配置库，那也起不到并行的效果

### MySQL 5.7 的并行复制策略

官方的 MySQL5.7 版本，由参数 slave-parallel-type 来控制并行复制策略：

1.  配置为 DATABASE，表示使用 MySQL 5.6 版本的按库并行策略； 
2. 配置为 LOGICAL_CLOCK，表示的就是类似 redo log 组提交 (group commit) 优化 。不过，MySQL 5.7 这个策略，针对并行度做了优化。这个优化的思路也很有趣儿。

### MySQL 5.7.22 的并行复制策略

在 2018 年 4 月份发布的 MySQL 5.7.22 版本里，MySQL 增加了一个新的并行复制策略，基于 WRITESET 的并行复制。

 相应地，新增了一个参数 binlog-transaction-dependency-tracking，用来控制是否启用这个新策略。这个参数的可选值有以下三种。 

1.  COMMIT_ORDER，表示的就是前面介绍的，根据同时进入 prepare 和 commit 来判断是否可以并行的策略 。
2.  WRITESET，表示的是对于事务涉及更新的每一行，计算出这一行的 hash 值，组成集合 writeset。如果两个事务没有操作相同的行，也就是说它们的 writeset 没有交集，就可以并行。 
3. WRITESET_SESSION，是在 WRITESET 的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序



### 这篇文章需要好好理解，下一次重新读一下原文

