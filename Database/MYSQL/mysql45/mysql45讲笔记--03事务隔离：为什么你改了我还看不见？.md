# 事务隔离：为什么你改了我还看不见？

数据库的特性：ACID（Atomicity、Consistency、Isolation、Durability即 原子性、一致性、隔离性、持久性）。

##  隔离级别

隔离性越严实↑，效率越低↓，SQL标准事务隔离级别：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化读(serializable )。

- 读未提交：一个事务还没提交时，他做的变更就能被别的事务看到。
- 读提交：一个事务提交之后，他做的变更才会被其他事务看到。
- 可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- 串行读：”写“会加“写锁”，读会加“读锁”，队列式执行，当出现读写锁冲突的时候，后一个事务必须等待前一个事务执行完成才能继续执行。

以下我们通过一个例子来理解这四种级别，假设存在数据表T中只有一列，其中地值为1，下面是按照时间顺序执行两个事务行为。

```mysql
mysql> create table T(c int) engine=InnoDB;
insert into T(c) values(1);
```

![](https://raw.githubusercontent.com/dddygin/image-storage/main/blog/image/database/mysql/mysql45/mysql45-03-01.png)

我们看一下在不同地隔离级别下，事务A会有那些不同地返回结果，即V1、V2 、V3的值是什么。

若为**“读未提交”**，V1、V2、V3都为2，原因是A事务在“**读未提交**”隔离级别可看到其他事务的更改。

若为“**读提交**”，V1为1，V2、V3为2，原因在V1时B事务还未提交，无法发读取到改变，在事务B提交后，V2、V3就能读取到事务B的改变，所以值为2。

若为“**可重复读**”，V1、V2为1，V3为2，原因是可重复读隔离级别，所读到的值都是都是前后一致的，V1、V2是在A事务里面的，所以值是一致的，V3是事务A提交了，可以读到事务B的改变。

若为“**串行化**”，事务A启动后查询了值，这时就加了读锁，而事务B启动后也进行了读取，不会被A的读锁锁住，再事务B要对值进行修改，会被A事务的读锁锁住，所以等待事务A的提交，所以V1、V2 为1，事务A提交完之后，事务A的的读锁释放，事务B会对值加写锁，V3的查询会被锁住，直到事务B提交。事务B提交完，V3查询值就为2.

在实现上，"**读未提交**"是直接返回最新的值；“**可重复读**”是在启动的事务时创建一个视图，整个事务期间都是用这个视图；“**读提交**”是在开始执行每条sql的时候创建视图（如果有其他事务提交了改变，这样执行sql的时候就能获取提交的改变）；“**串行化**"是通过加锁的方式避免并行访问。

>MySQL的默认隔离级别是**可重复读**
>
>Oracle的默认隔离级别是**读提交** ，所以在Oracle迁库到MySQL要改变隔离级别防止错误

MySQL修改隔离级别

```mysql

mysql> show variables like 'transaction_isolation';

+-----------------------+----------------+

| Variable_name | Value |

+-----------------------+----------------+

| transaction_isolation | READ-COMMITTED |

+-----------------------+----------------+
```

## 事务隔离的实现

下面以“**可重复读**”为例子看一下事务隔离级别具体是怎么实现的。

在MySQL中，实际上每一条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值可以通过回滚操作得到前一个状态值。

假设一个值从1按照顺序改成了2、3、4，在回滚日志就会有以下类似的记录。

![](https://raw.githubusercontent.com/dddygin/image-storage/main/blog/image/database/mysql/mysql45/mysql45-03-02.png)

当前值是4，但是在查询这条记录的时候，不同时刻的事务会有不同的read-view。如图看到的，在视图A、B、C里面，这一个记录分别为1、2、4，同一条记录可以存在多个版本，这就是数据库的多版本并发控制(MVCC)。对于read-viewA要得到1，就必须将当前的值**执行途中所有**的回滚所得。

回滚日志什么时候删除？，答案是在不需要的时候才删除，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志才会被删除。什么时候才不需要呢？就是当系统里面没有比这回滚日志更早的read-view的时候。

> 这也是我们不建议使用长事务，因为长事务意味着系统里面会存在很老的事务视图，由于这些事务随时可能访问数据库里面的任何数据，所有这个事务提交前，数据库里面它都有可能用到回滚记录都必须保存，会导致大量的占用存储空间。

## 事务的启动方式

MySQL的事务启动方式有以下几种：

1. 显示启动事务语句，begin 或者 start transaction。配套的提交语句是commit，回滚语句是rollback。
2. set autocommit=0，这个命令会将线程的自动提交关掉。这就意味着你只要执行语句这个事务就会启动了，而且不会自动提交，直到你主动执行commit或者rollback，或者断开连接。

> 基于长连接的利弊，我们建议使用set autocommit=1，通过显示的方法来启动事务。

在 autocommit 为1的情况下，用begin显式启动事务，如果执行commit则提交事务；如果执行commit work and chain ，则是提交事务并自动启动下一个事务，这样省去了再一次执行begin语句的开销。

查找长事务，以下式查找事务持续超过60s额事务

```mysql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```





## 自问自答

1. 什么是数据库的多版本控制（MVCC）？

   官方回答： 全称`Multi-Version Concurrency Control`，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存 。

   通俗回答： MVCC多版本并发控制指的是 **“维持一个数据的多个版本，使得读写操作没有冲突”** 这么一个概念。仅仅是一个理想概念 

   > 可参考[文章一](https://blog.csdn.net/SnailMann/article/details/94724197)、[文章二]( https://baijiahao.baidu.com/s?id=1629409989970483292&wfr=spider&for=pc ) 理解readview是怎么去实现mvcc原理的







































