# MySQL是怎么保证高可用的？

### 主备延迟

主备延迟是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值。

**如何查看主备延迟的时间？**

可以在备库中执行 <font color='orange'>show slave status</font> 命令，它返回的结果里面会显示 <font font color='orange'>seconds_behind_master </font>,用于显示当前备库延迟多少秒。

>  seconds_behind_master 的计算方法是这样的： 
>
> 1. 每个事务的binlog 里面都有一个字段，用于记录主库上写入的时间
> 2. 备库取出当前执行的事务的时间的值，计算它于当前系统时间的差值，得到 seconds_behind_master。
>
> 或许你会问，如果主备机器的系统时间不一致怎么办？
>
> 其实不会的有问题的，如果发现主备时间不一致，备库执行会自动扣除这个差值的。



### 什么原因导致主备延迟

**1、主备机器性能不一致**

在有些部署条件下，备库所在的机器的性能要比主库所在的机器的性能差。

因为更新请求对 IOPS 的压力，在主库和备库上是无差别的。所以，在这种部署时，一般都会将备库设置为“非双 1”的模式

**2、备库的压力大**

一般情况下，主库提供写能力，备库提供一些读能力。或者一些运营后台需要分析语句，不能影响正常业务，所以只能在备库上跑。因为没有克制的在备库运行SQL，结果时，备库上的查询耗费了大量的 CPU 资源，影响了同步速度，造成主备延迟。 

*解决方法*

- 一主多从。除了备库外，可以多连接几个从库，让这些从库分担读的压力。
- 通过 binlog 输出到外部系统，比如 hodoop 这类系统，让外部系统提供统计类查询的能力。

**3、大事务**

因为主库上必须等待事务执行完成才会写入 binlog ，再传给备库，如果一个主库上的语句执行10分钟，那么这个事务可能就会导致从库延迟10分钟。

- 比如，一次性地用 delete 语句删除太多数据，这个是典型地大事务场景
- 大表的 DDL

### 主备切换策略

**可靠性优先策略**

![](https://raw.githubusercontent.com/dddygin/image-storage/main/blog/image/database/mysql/mysql45/mysql45-25-01.png)

<center>图 2 MySQL 可靠性优先主备切换流程</center>

1. 判断备库 B 现在的 second_behind_master,如果小于某个值（比如5秒）继续下一步，否则持续重试这一步；
2. 把主库 A 改成只读状态，即把 readonly 设置为 true；
3. 判断备库 B 的 seconds_behind_master 的值，直到这个值变为 0 为止；
4. 把备库 B 改成可读写状态，也就是把 readonly 设置为 false；
5. 把业务请求切换到备库 B。

**可用性优先策略**

如果我强行把步骤 4、5 调整到最开始执行，也就是说不等主备数据同步，直接把连接切换到备库 B，并且让备库 B 可以读写，那么系统几乎就没有不可用时间了。

我们把这个切换流程，暂时称作可用性优先流程。这个切换流程的代价，就是可能出现数据不一致的情况。



大多数情况下，我都建议你使用可靠性优先策略。毕竟对数据服务来说的话，数据的可靠性一般还是要优于可用性的。
