# 31、误删数据后除了跑路，还能怎么办？

**误删数据的类型：**

1. 使用 delete 语句误删除数据行；
2. 使用 drop table 或者 truncate table
3. 使用 drop database 语句误删数据库；
4. 使用 rm 命令误删整个 MySQL 实例。

### 误删行（修改了行）

- **原理**：修改 binlog 的内容，拿回到原库重放。
- **恢复条件：**需要确保 binlog_format=row 和 binlog_row_image=FULL
- **恢复类型：**
  1. 对于 insert 语句，对应的 binlog event 类型是 Write_rows event，把它改成 Delete_rows event 即可； 
  2. 对于 delete 语句，也是将 Delete_rows event 改为 Write_rows event；
  3. 而如果是 Update_rows 的话，binlog 里面记录了数据行修改前和修改后的值，对调这两行的位置即可。
  4. 如果误操作不是一个，而是多个。涉及到了多个事务的话，需要将事务的顺序调过来再执行。
- **工具：** Flashback 
- **建议：**不建议直接在主库上执行这些操作。比较安全的做法是，恢复出一个备份，或者找一个从库作为临时库，这个临时库上执行这些操作，然后确认过临时库的数据，恢复回主库。（原因防止对数据进行二次破坏）
- **预防措施：**
  1. 把 sql_safe_updates 参数设置位 on。防止 delete 或者 update 语句中不带条件，或者没有包含索引字段，就会报错
  2. 代码上线前，必须经过 SQL 审计。

### 误删库 / 表

- **原理：**通过全量备份恢复出一个数据库实例，在这个数据实例上执行全量备份的时间点到删库时这段时间的 binlog。

- **恢复条件：** 定时全量备份 和 实时备份binlog

- **恢复步骤：**

  1. 取出最近一次全量备份,假设这个库是一天一备，上次备份是当天 0 点； 
  2. 用备份恢复出一个临时库；
  3. 从日志备份里面，取出凌晨 0 点之后的日志；
  4. 把这些日志，除了误删除数据的语句外，全部应用到临时库。

- **注意：**

  1. **加速数据恢复：**如果这个临时库上有多个数据库，你可以在使用 mysqlbinlog 命令时，加上一个–database 参数，用来指定误删表所在的库。（减少数据）
  2. 需要跳过误操作的那个 binlog ：
     - 如果原实例没**有使用 GTID 模式**，只能在应用到包含 误操作那个点的 binlog 文件的时候，先用–stop-position 参数执行到误操作之前的日志，然后再用–start-position 从误操作之后的日志继续执行；
     - 如果实例使用了 GTID 模式，就方便多了。假设误操作命令的 GTID 是 gtid1，那么只需要执行 set gtid_next=gtid1;begin;commit; 先把这个 GTID 加到临时实例的 GTID 集合，之后按顺序执行 binlog 的时候，就会自动跳过误操作的语句

- **恢复速度为什么慢：**

  1. 如果误删除表，但是mysqlbinlog 工具并**不能指定只解析一个表的日志**；
  2. **单线程**， 应用日志的过程就只能是单线程 。

- **如何加速**：

  1. 在用备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库。
  2. 在 start slave 之前，先通过执行﻿﻿change replication filter replicate_do_table = (tbl_name) 命令，就可以让临时库只同步误操作的表；

### 延迟复制备库

以上两种情况可以恢复数据的前提是**都要求备份系统定期备份全量日志，而且需要确保 binlog 在被从本地删除之前已经做了备份。**

所以提供了另外一种思路的方法，延迟复制备库。

- **核心思想：** 搭建延迟复制的备库**。

1. 一般的主备复制结构存在的问题是，如果主库上有个表被误删了，这个命令很快也会被发给所有从库，进而导致所有从库的数据表也都一起被误删了。
2. 延迟复制的备库是一种特殊的备库，通过 CHANGE MASTER TO MASTER_DELAY = N 命令，可以指定这个备库持续保持跟主库有 N 秒的延迟。
3. 这个命令就还没有在这个延迟复制的备库执行。这时候到这个备库上执行 stop slave，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。

- **预防：**
  1. 账号分离 （每个账号控制好权限）
  2. 制定操作规范。这样做的目的，是避免写错要删除的表名：
     - 在删除数据表之前，必须先对表做改名操作。然后，观察一段时间，确保对业务无影响以后再删除这张表。
     - 改表名的时候，要求给表名加固定的后缀（比如加 _to_be_deleted)，然后删除表的动作必须通过管理系统执行。并且，管理系删除表的时候，只能删除固定后缀的表。

### rm 删除数据

**核心原理**：搭建高可用MySQL集群。

对于一个有高可用机制的 MySQL 集群来说，最不怕的就是 rm 删除数据了。只要不是恶意地把整个集群删除，而只是删掉了其中某一个节点的数据的话，HA 系统就会开始工作，选出一个新的主库，从而保证整个集群的正常工作。

### 
