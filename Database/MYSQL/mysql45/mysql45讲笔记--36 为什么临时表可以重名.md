# 36 | 为什么临时表可以重名？

### 什么是临时表？

**临时表和内存表**

- 内存表，指的是使用 Memory 引擎的表，建表语法是 <font color='orange'>create table ... engine=memory</font>。这种表数据保存在内存里，系统重启的时候会被清空，但是表结构还在。
- 临时表，可以使用各种引擎类型。建表语法是 <font color='orange'>create temporary table ... engine=xxx</font> 如果使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数据的时候是写到磁盘上的，当然临时表也是可以使用 Memory 引擎。

**临时表的特性**

![](https://raw.githubusercontent.com/dddygin/image-storage/main/blog/image/database/mysql/mysql45/mysql45-36-01.png)

<center>图 1 临时表特性示例</center>

**临时表的特点：**

1. 建表语法是 create temporary table....；
2. 一个临时表只能被创建它的 session 访问，对其他线程不可见。（所以，图中 session A 创建的临时表 t，对于 session B 就是不可见的）；
3. 临时表可以与普通表同名；
4. session A 内又同名的临时表和不同表的时候，show create 语句，以及增删改查语句访问的是临时表；
5. show tables 命令不显示临时表。
6. session 结束的时候，会自动删除临时表。

**应用方向**

**第一种：join**

由于临时表只能被创建它的 session 访问，所以在这个 session 结束的时候，会自动删除临时表。 也正是由于这个特性，临时表就特别适合上篇文章的 join 优化这种场景。

主要的两个原因：

1. 不同 session 的临时表是可以重名的，如果有多个 session 同时执行 join 优化，不需要担心表名重复导致建表失败的问题。
2. 不用担心数据删除问题。如果使用普通表，在流程过程中客户端发生异常断开，或者数据库发生异常重启，还需要专门来清理中间过程中生成的数据表。而临时表由于会自动回收，所以不需要这个额外的操作。

**第二种：对于分库分表的场景**

由于分库分表，一份数据分散在不同的数据库实例中，如果要执行查询并且排序，这样就导致数据分散在不同数据库实例中。这时临时表就发挥它的功能，先从每个数据库实例中拿到满足条件的记录，存到临时表中，在执行排序，返回记录即可。

**在实践中，我们往往会发现每个分库的计算量都不饱和，所以会直接把临时表 temp_ht 放到 32 个分库中的某一个上。**

### 为什么临时表可以重名？

以下面语句为例：

```mysql
create temporary table temp_t(id int primary key)engine=innodb;
```

**表结构：**

MySQL 要给这个 InnoDB 表创建一个frm文件保存文件表定义。**而 frm 文件放在临时文件目录下，文件名的后缀是 .frm,前缀是 “# sql{进程id}\_{线程id}\_序列号”**。 使用 select @@tmpdir 命令，来显示实例的临时文件目录 

**表数据：**

在不同的 MySQL 版本中有着不同的处理方式：

- 在 5.6 以及之前的版本里，MySQL 会在临时文件目录下创建一个相同前缀、以.ibd 为后缀的文件，用来存放数据文件；
- 而从 5.7 版本开始，MySQL 引入了一个临时文件表空间，专门用来存放临时文件的数据。因此，我们就不需要再创建 ibd 文件了。

从文件名的前缀规则，我们可以看到，其实创建一个叫作 t1 的 InnoDB 临时表，MySQL 在存储上认为我们创建的表名跟普通表 t1 是不同的，因此同一个库下面已经有普通表 t1 的情况下，还是可以再创建一个临时表 t1 的。

**table_def_key **

MySQL 维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个 table_def_key。

- 一个普通表的 table_def_key 的值是由“库名 + 表名”得到的，所以如果你要在同一个库下创建两个同名的普通表，创建第二个表的过程中就会发现 table_def_key 已经存在了。
- 而对于临时表，table_def_key 在“库名 + 表名”基础上，又加入了“server_id+thread_id”。

也就是说，session A 和 sessionB 创建的两个临时表 t1，它们的 table_def_key 不同，磁盘文件名也不同，因此可以并存。

在实现上，每个线程都维护了自己的临时表链表。这样每次 session 内操作表的时候，先遍历链表，检查是否有这个名字的临时表，**如果有就优先操作临时表，如果没有再操作普通表；在 session 结束的时候，对链表里的每个临时表，执行 “DROP TEMPORARY TABLE + 表名”操作**。

### 临时表和主备复制

 你可以设想一下，在主库上执行下面这个语句序列： 

```msyql
create table t_normal(id int primary key, c int)engine=innodb;/*Q1*/
create temporary table temp_t like t_normal;/*Q2*/
insert into temp_t values(1,1);/*Q3*/
insert into t_normal select * from temp_t;/*Q4*/
```

如果关于临时表的操作都不记录，那么在备库就只有 create table t_normal 表和 insert into t_normal select * from temp_t 这两个语句的 binlog 日志，备库在执行到 insert into t_normal 的时候，就会报错“表 temp_t 不存在”。

你可能会说，如果把 binlog 设置为 row 格式就好了吧？因为 binlog 是 row 格式时，在记录 insert into t_normal 的 binlog 时，记录的是这个操作的数据，即：write_row event 里面记录的逻辑是“插入一行数据（1,1)”。

**注意：**

确实是这样。如果当前的 binlog_format=row，那么跟临时表有关的语句，就不会记录到 binlog 里。也就是说，只在 binlog_format=statment/mixed 的时候，binlog 中才会记录临时表的操作。

这种情况下，创建临时表的语句会传到备库执行，因此备库的同步线程就会创建这个临时表。主库在线程退出的时候，会自动删除临时表，但是备库同步线程是持续在运行的。所以，这时候我们就需要在主库上再写一个 DROP TEMPORARY TABLE 传给备库执行。

- 如果 binlog_format=row, 也就是临时表的数据不会同步到备库中，如果我们先在所在的session 创建了临时表，如果主库上执行 "drop table t_normal, temp_t"这个命令，那么 binlog 中就只能记录：

  ```msyql
  DROP TABLE `t_normal` /* generated by server */
  ```

  因为备库上并没有表 temp_t，将这个命令重写后再传到备库执行，才不会导致备库同步线程停止。

  

- 如果 binlog_format不是row, MySQL 在记录 binlog 的时候，会把主库执行这个语句的线程 id 写到 binlog 中 。这样，在备库的应用线程就能够知道执行每个语句的主库线程 id，并利用这个线程 id 来构造临时表的 table_def_key：

  1.  session A 的临时表 t1，在备库的 table_def_key 就是：库名 +t1+“M 的 serverid”+“session A 的 thread_id”; 
  2.  session B 的临时表 t1，在备库的 table_def_key 就是 ：库名 +t1+“M 的 serverid”+“session B 的 thread_id” 

