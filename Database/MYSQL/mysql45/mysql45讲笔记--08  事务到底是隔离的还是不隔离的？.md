# 08 | 事务到底是隔离的还是不隔离的？

在**可重复读级别下**，事务T启动会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的数据还是和启动时看到的一样。但是，我们也知道一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，它会受到行锁的限制，会被锁住，进入等待状态。问题是，既然进入等待状态，那么等到这个事务自己获取到行锁要更新的时候他读到的值又是什么呢？

举个“栗子”，**前提是在可重复读隔离级别下**，创建一个只有两行的表格初始语句。

```mysql
mysql> CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `k` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, k) values(1,1),(2,2);
```

![](https://raw.githubusercontent.com/dddygin/image-storage/main/blog/image/database/mysql/mysql45/mysql45-08-01.png)

<center>图1 事务 A、B、C的执行过程</center>
> <font color=orange>begin/start transaction</font> 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才会真正的启动。一致性视图时在在执行第一个快照读语句时创建。
>
> 如果你想马上启动一个事务，你可以使用<font color=orange> start transaction with consistent snapshot </font>这个命令，执行这个命令后 会创建一致性视图。

这个例子中，事务C没有显式额使用begin/commit，表示这个update 语句本身就是一个事务，语句完成的时候会自动提交。事务B在更新了行之后查询；事务A在一个只读事务中查询，并且时间顺序上市在事务B查询之后。

如果现在告诉你事务B查到的值是3，而事务A查询到的值是1，这个答案真是让人头大。借由这个疑惑解开的过程，我们来进一步理解事务和锁。

在MySQL中，有两个“视图”的概念“

-  一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询并生成结果。创建视图的语句是create view  \<视图名\> as \<select语句\> ，而查询的方法是和表一样。
- 另一个是 InnoDB 在实现MVCC时用到的一致性读视图，即consistent read view，用于支持RC（Read Commit，读提交）和RR（Repeatable Read,可重复读）隔离级别的实现

###  快照在MVCC里面时怎么工作的？

在可重复隔离级别下，事务在启动的时候就”拍了个快照“。注意这个快照时基于整个库的。

我靠，这个不太现实，如果我的数据的数据是100G，每次启动事务就复制100G，那这个空间和速度都是没法跟的上的，这个不现实。所以我们要了解MVCC中的快照是怎么实现，绝不做文盲（哈哈，吹牛B）。

其实，**InnoDB 里面每一个事务都有一个唯一的事务ID **，叫做 transaction id 。他是**在开始的时候向 InnoDB 的事务系统申请的，是按照申请顺序严格递增的**。

而每行数据也都是多个版本的，每次事务更新的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务ID，记为 row trx_id。同时旧的数据版本要保留，并且在新的数据库版本中，能够有信息可以直接拿到它。

也就是说，数据表中的一行记录，其实可能有多个版本（row），每一个版本有自己的row trx_id。

如图2 ，就是一个记录被多个事务连续更新后的状态。

![](https://raw.githubusercontent.com/dddygin/image-storage/main/blog/image/database/mysql/mysql45/mysql45-08-02.png)

<center>图2 行状态变更图</center>
实际上，图2中的三个虚拟箭头就是undo log；而V1、V2、V3并不是物理上真实存在的，而是每次需要的时候根据当前版本和undo log（回滚日志）计算出来的。比如需要V2的时候需要依次执行U3和U2算出来的。

可重复读的定义：一个事务启动的时候，能够看到自己已经提交的事务结果，但是之后，这个事务执行期间，其他食物的更新对他是不可见的。

所以在可重复读隔离级别下，一个事务只需要在启动的时候声明说，”以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，我就认；如果是我启动以后生成的，我就不认，我必须找到它的上一个版本“。

而在具体的实现上,InnoDB 为每一个事务都构造了一个数组，用来保存事务启动瞬间，当前正在活跃的所有事务ID，**"活跃"指的是，启动了但还没有提交**。

**数组里面事务ID的最小值**记为低水位，当前系统里面**已经创建过的事务ID**的最大值加1记为高水位。

这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。

而版本的可见性规则，就是基于数据的row trx_id 和这个一致性视图对比结果得到的。

这个视图数据组把所有的row trx_id 分成了几种不同的情况

![](https://raw.githubusercontent.com/dddygin/image-storage/main/blog/image/database/mysql/mysql45/mysql45-08-03.png)

<center>图3 数据版本可见性规则</center>
这样,对当前事务的启动瞬间来说，一个数据版本的row trx_id,有以下几种可能：

1. 如果落在绿色部分，表示这个版本已提交的事务或者是当前事务 自己生成的，这个事务时可见的；
2. 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；
3. 如果落在黄色部分，那就包括两种情况:
   - 若row trx_id 在数组中，表示这个版本是由未提交的事务生成的，不可见；
   - 若row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见；

现在我们知道了，**InnoDB 利用了“所有数据有多个版本”的特性，实现了“秒级创建快照“的能力**。

接下来我们就来分析一下我们遗留的疑问，事务A k为什么是1。**以下分析很重要**

这里，我们不妨假设：

1. 事务A开始前，系统只有一个活跃事务ID是99；
2. 事务A、B、C的版本号分别是100、101、102，且当前系统只有这四个事务；
3. 三个事务开始前，(1,1)这一行数据的row trx_id 是90。

这样，事务A的视图数组是[99,100],事务B的视图数组是[99,100,101],事务C的视图数组是[99,100,101,102]。

为了简化分析，只画出了跟事务A查询逻辑有关的操作：

![](https://raw.githubusercontent.com/dddygin/image-storage/main/blog/image/database/mysql/mysql45/mysql45-08-04.png)

<center>图4 事务A查询数据逻辑图</center>
从图中可以看到，第一个有效更新是事务C，把数据从（1，1）改成了（1，2）。这时候，这个数据的最新版本的row trx_id是102，而90这个版本成为了历史版本。

第二而有效的更新是事务B，把数据从（1，2）改成了（1，3）这时候，这个数据的最新版本（即row trx_id）是101，而102又成为了历史版本。

你可能注意到了，在十五A查询的时候，其实事务B还未提交，但是它生成的（1，2）这个版本已经变成了当前版本了，这个版本对事物A必须是不可见的，否则就成了脏读了。

好，现在事务A要来读数据，它的视图数组是[99,100],当然了，**读取数据都是从当前版本读起的**。所以，事务A查询语句的读数据流程是这样的:

- 找到（1，3）的时候，判断出row trx_id=101,比高水位大，落在红色区域，不可见；
- 继续，找到三个版本，一看row trx_id=102,比高水位大，落在红色区域，不可见；
- 接着，终于找到了（1，1），它的row trx_id=90,比低水位小，处于绿色区域，可见。

这样执行下来，虽然期间这一行数据被修改过，但是事务A无论在什么时候看到这行数据的结果都是一致的，所以我们称之为**一致性读**。

**总结一下规律：对于一个事务视图来说，除了自己的更新总是可见的，还有三种情况**

- 版本未提交，不可见；
- 版本已提交，但是是在视图创建后提交的，不可见
- 版本已提交，而且是在视图创建前提交的，可见。

### 更新逻辑

<font color=orange>按照一致性读的标准，那事务B输出的结果好像不正确哦?</font>（我也是全文充满了疑惑，为什么是3，直到下面的一句话，细心看，重要啊！！！）

你看图5中，事务B的视图数据组是先生成的，之后事务C才提交，不是应该看不见（1，2）吗，怎么算的出来（1，3）来呢？？？

![](https://raw.githubusercontent.com/dddygin/image-storage/main/blog/image/database/mysql/mysql45/mysql45-08-05.png)

<center>图5 事务B更新逻辑图</center>
是的，**如果事务B在更新之前查询一次数据，这个查询返回的k值的确是1**。

但是，当它要去更新数据时候，就不能在历史版本上更新了，否则事务C的更新就丢失了。因此，事务B此时的set k=k+1是在（1，2）的基础上进行操作。

所以<font color="orange">这里就用到了这样一条规则</font>：**更新数据都是先读后写的，而这个读，只能读当前的值，称之为”当前读（current read）“**

因此，在更新的时候，当前读拿到的数据是（1，2），更新后生成了新的数据（1，3），这个版本的row trx_id 是101。这个就是为什么查看到k值位3的原因了。

这里我们提到了一个概念叫做**当前读**，其实，<font color="orange">除了update语句之外，select语句如果加锁了，也是当前读</font>。

所以，如果把事务A的查询语句 select * from t where id=1 修改一下，加上 lock in share mode 或者 for update，也都可以读到版本号是101的数据，返回的k的值是3。下面两条 select 语句，就分别加了读锁（S 锁，共享锁）和写锁（X锁，排他锁）。

```mysql
mysql> select k from t where id=1 lock in share mode;
mysql> select k from t where id=1 for update;

```



再往前一步，加上事务C不是马上提交，而是变成了下面的事务C’，会怎么样呢？？（<font color="orange">真的是个好问题啊!!!</font>）

![](https://raw.githubusercontent.com/dddygin/image-storage/main/blog/image/database/mysql/mysql45/mysql45-08-06.png)

<center>图6 事务A、B、C‘ 的执行流程</center>
事务C’ 的不同是，更新并没有马上提交，在他提交前，事务B的更新语句先发起了，前面说个了，虽然事务C‘ 还没有提交，但是（1，2）这个版本已经生成了，并且是当前最新的版本，那么事务B在更新的时候会这么处理呢？

这里我们需要先复习一下一个概念”<font color="orange">两阶段锁协议</font>“：在InnoDB事务中，行锁是在需要的时候加上去的，但并不是不需要了就立即释放。这就是两阶段协议。事务C’虽然启动的比事务B晚，但是事务C‘先更新了k值，所以先锁住了id=1的这一行，而且事务C’没提交，也就是说（1，2）这个版本上的锁还没有释放。而事务B就是当前读，必须读最新版本，而且必须加锁，因此就被锁住了，必须等到事务C‘ 释放这个锁，才能继续它的当前读。

![](https://raw.githubusercontent.com/dddygin/image-storage/main/blog/image/database/mysql/mysql45/mysql45-08-07.png)

<center>图7 事务B更新逻辑图（配合事务C’）</center>
到这里，我们就把一致性读、当前读和行锁就串起来了。

**可重复读的核心就是一致性读；而事务更新数据的时候，只能用当前读。如果当前记录的行锁被其他事务所占用，就只能进入锁等待**。

**而读提交的逻辑和可重复读的逻辑类似**，主要的区别是：

- 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都公用这个一致性视图；
- 在读提交隔离级别下，每个语句执行前都会重新算出一个新的视图（看看有没有其他事务更新了数据，并且提交了事务）

那么我们看一下在读提交隔离级别下，第一个问题中的事务A和事务B的查询语句查到的k值分别是多少？

> 这里需要说明一下，“start transaction with consistent snapshot” 的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以在都提交隔离级别下，这个用法就没有意义了，等同于 start transation。

![](https://raw.githubusercontent.com/dddygin/image-storage/main/blog/image/database/mysql/mysql45/mysql45-08-08.png)

<center>图8 都提交隔离级别下的事务状态图</center>
这时，事务A的查询语句的视图数组是在执行这个语句的时候创建的，时序上（1，2）、（1，3）的生成时间都在创建这个视图数组之前。但是这个时刻：

- （1，3）还未提交，属于第一种情况，不可见；
- （1，2）提交了，属于第三种情况，可见。

所以 这个时候事务A查询语句返回的是k=2。事务B查询的结果是k=3。
