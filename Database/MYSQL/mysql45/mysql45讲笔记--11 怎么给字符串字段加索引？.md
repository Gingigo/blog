# 11 | 怎么给字符串字段加索引？

假如需要为邮箱登录系统中的用户表中邮箱字段添加一个索引，用户表如下：

```mysql
mysql> create table SUser(
ID bigint unsigned primary key,
email varchar(64), 
... 
)engine=innodb; 
```

我们查询业务中一定会用到类似这样的语句

```mysql
mysql> select f1, f2 from SUser where email='xxx';
```



## 完整索引

直接添加完整索引的 SQL 语句如下

```mysql
mysql> alter table SUser add index index1(email);
```

- **优点**：
  1. **减少查询的次数**，因为完整索引，整个字段都被包含了，减少了扫描次数。
  2. **可能用上覆盖索引**，因为完整的索引，包含了整个字段的内容，如果 SQL是可以覆盖索引的要求，用上覆盖索引速度更快。
- **缺点**：
  1. **消耗磁盘空间大**，索引选取的的越长，占用的磁盘空间就越大。
  2. **搜索效率低**，因为相同的数据页能放下的索引值就越少，搜索效率就越低。

**适用场景**：

1. **表格记录数据不多**（业务优先），数据量少，自然避开了上面两个缺点。
2. **前缀区分度不低 或者需要用上覆盖索引**，无法使用前缀索引，就利用优点1，2



## 前缀索引

添加前缀索引的SQL 如下：

```mysql
mysql> alter table SUser add index index2(email(6));
```

- **优点**：
  1. **消耗磁盘空间小**，索引选取的的越小，占用的磁盘空间就越小
  2. **搜索效率高**，因为相同的数据页能放下的索引值就越多，搜索效率就越高
- **缺点**：
  1. **可能增加查询的次数**，因为前缀索引只包含规定长度，无法准确的表达整字段，所以需要回表查询全字段在进行判断，增加了查询的次数。
  2. **不能使用覆盖索引**，因为因为前缀索引只包含规定长度，无法准确的表达整字段。

**适用场景**：

1. **数据区分度好**，能用更小的长度的索引，找出数据，同时省磁盘空间。



## 倒序存储

由于前缀索引，前面的字符必须区分度好才能，有效的利用器前缀索引的有点，但是有一个场景就是要维护一个市的身份证号码的时候，前面的几个字符都是相同的，则是就不能很好的利用了。所以我们可以讲身份证号码倒序存储，然后该字段再用前缀索引。SQL如下：

```mysql
mysql> select field_list from t where id_card = reverse('input_id_card_string');
```

- **优点**：
  1. **消耗磁盘空间小**，索引选取的的越小，占用的磁盘空间就越小。
  2. **搜索效率高**，因为相同的数据页能放下的索引值就越多，搜索效率就越高。
  3. **不会占用额外的空间存储倒序。**
- **缺点**：
  1. **可能增加查询的次数**，因为前缀索引只包含规定长度，无法准确的表达整字。段，所以需要回表查询全字段在进行判断，增加了查询的次数。。
  2. **不能使用覆盖索引**，因为因为前缀索引只包含规定长度，无法准确的表达整字段。
  3. **每次读写都需要调用reverse()函数**。
  4. **无法利用索引的范围查询**
  5. **存在一定的冲突的概率**

**适用场景**：

1. **数据前缀区分不好，后缀区分度度好**，倒叙之后能用上前缀索引。



## hash字段索引

可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。SQL 如下：

```mysql
mysql> alter table t add id_card_crc int unsigned, add index(id_card_crc);
```

然后每一次插入新记录的时候，都同时用crc32()这个函数得到校验码填写到这个新字段。由于校验码存在冲突，也就是说两个不同的身份证通过crc32（）函数得到相同的结果，所以查询语句需要再where部分要添加id_card的精确值。SQL 如下：

```mysql
mysql> select field_list from t where id_card_crc=crc32('input_id_card_string') and id_card='input_id_card_string'
```

- **优点**：

  1. **消耗磁盘空间小**，索引选取转换成为长度小的hash值，占用的磁盘空间就越小。
  2. **搜索效率高**，因为相同的数据页能放下的索引值就越多，搜索效率就越高。

- **缺点**：

  1. **不能使用覆盖索引**，因为因为前缀索引只包含规定长度，无法准确的表达整字段。
  2. **每次读写都需要调用crc32()函数**。
  3. **无法利用索引的范围查询**
  4. **增加了一个字段**

  **适用场景**：

1. **区分不好，数据长度长**，提升了区分度，和减少了索引长度



## 区分度

实际上，我们在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。

首先，你可以使用下面这个语句，算出这个列上有多少个不同的值：

```mysql
mysql> select count(distinct email) as L from SUser;
```

然后，依次选取不同长度的前缀来看这个值，比如我们要看一下 4~7 个字节的前缀索引，可以用这个语句：

```mysql
mysql> select 
  count(distinct left(email,4)）as L4,
  count(distinct left(email,5)）as L5,
  count(distinct left(email,6)）as L6,
  count(distinct left(email,7)）as L7,
from SUser;
```

