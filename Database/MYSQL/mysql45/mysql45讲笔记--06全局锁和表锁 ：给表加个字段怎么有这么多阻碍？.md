# 全局锁和表锁 ：给表加个字段怎么有这么多阻碍

**为什么需要数据库锁？**，数据库锁的初衷是**解决并发问题**。数据库作为多用户共享的资源，当出现并发访问时，数据库需要合理地控制资源访问规则，而锁就是用来实现访问规则地重要数据结构。

**按照加锁地范围分，可以分成全局锁、表级锁、行锁三类。**

## 全局锁

全局锁是对整个数据库实例加锁。MySQL提供了一个加**全局读锁的方法**，命令是`Flash tables with read lock`(FTWRL)。这条命令会让整个数据库处于**只读状态**，**其他线程的数据更新（数据的增删改）、数据的定义（建表、修改表结构等）和更新类事务的提交语句全部阻塞**。

**应用场景：做全库逻辑备份**

**缺点**：

- 如果在主库上做备份，主库在备份期间都不能执行更新，业务基本停摆。
- 如果在备库上做备份，备库备份期间不能执行主库同步过来的binlog，会导致主从延迟。

**优点**：备份数据期间不会因为更新导致数据逻辑不一致。在还原备份数据时保证了数据的正确性。

> 我们曾经在第三节在可重复读隔离级别下开启一个一致性视图，这样也能到达同样的效果。

官方自带的逻辑工具时mysqldump。当mysqldump使用参数-single-transaction的时候，导出数据之前就会启动一个事务，来确保拿到一致性视图，由于MVCC的支持，这个过程中数据是可以正常更新的。

那为什么需要FTWRL? 一致性读是好，**但前提是引擎要支持这个隔离级别**。比如MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是能拿到最新的数据，这样破坏了备份的一致性。这时就只能用FTWRL了。

所以**single-transaction方法只适用于所有的表使用事务引擎的库**，如果有的表使用了不支持事务的引擎，那么备份就只能通过FTWRL方法。

还有一种情况，要让**全库只读，为什么不使用set global readonly=true的方式能？**

不推荐使用`set global readonly=true`方式来做数据备份原因有二

- 一是，有些系统中readonly的值会被用来做其他逻辑，比如用它来判断一个库是主库还是从库。因此修改global变量的方式影响更大，不建议你使用。
- 二是，在异常处理机制上有异常，如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放整个全局锁，整个库回到正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常数据库会一直保持readonly状态，这样导致整个库长时间处于不可写，风险较高。

## 表级锁

MySQL里面表级别的锁有两种：一种时表锁，一种时元数据锁（mete data lock MDL）

### 表锁

**表锁的语法时  lock tables ... read/write**。于FTWRL类似，可以**unlock tables** 主动释放锁，也可以在客户端断开的时候自动释放。*要注意的是，lock tables 语法除了会限制出别的线程的读写外，也限定本线程接下来的操作对象（就是**所有的线程**都会受到锁的限制，但是限定的范围不一样，看下面一个例子）*

> 如果在某个线程A中执行 `lock tables t1 read,t2 write;`这个语句，则**其他线程**，写t1、读写t2都会被阻塞，**可以访问其他的表**。同时线程A在执行unlock tables之前，也是只能读t1、读写t2，**不能访问其他的表**。

缺点：锁表整个影响面太大了，不利于并发。

### MDL

**另一类表级的锁是MDL**。MDL不需要显式使用，在访问一个表的时候会被自动的加上。MDL的作用是保证读写的正确性。确保在读写过程中不会因为**表结构**发生变化而出错。

在MySQL5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加上MDL读锁；当要对表结构表更的时候加MDL写锁。

- MDL读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
- 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此如果有两个线程要同时给一个表加字段，其中一个要等待另一个执行完成才能开始执行。

#### 注意

虽然MDL锁是系统默认会加的，但却是你不能忽略的一个机制，举一个例子：给一个小表加个字段，导致整个库挂了。

我们都知道，给一个表加一个字段，或者修改字段，或者加索引，需要扫描全表数据。在对大表操作的时候我们特别小心，以免对线上服务器造成影响。而实际上小表，操作不慎也会出问题。假设表t是一个小表。

> 备注：实验环境是以MySQL5.6。

![](https://raw.githubusercontent.com/dddygin/image-storage/main/blog/image/database/mysql/mysql45/mysql45-06-01.jpg)



我们可以看到session A 先启动，这时会对表t加一个MDL读锁。由于session B需要的也是MDL读锁，因此可以正常执行。

之后session C 会被blocked，这是因为sessionA的MDL读锁还没有释放，而session C需要MDL写锁，因此会被阻塞。

如果session C自己被阻塞还没有什么关系，但是之后所有要在表t上新申请MDL读锁的请求也会被session C阻塞。前面我们说了，所有对表的增删改查操作需要先申请MDL读锁，就都被锁住了，等于这个表现在完全不可以读写了。

如果表上的查询语句频繁，而且客户端有重试机制，也就是说超时再发起一个新session再请求的话，这个库的线程很快就会爆满。

你现在应该知道了，事务中的MDL锁，在语句开始时申请，但是语句结束并不会马上释放，而会等到整个事务提交完成后再释放。

**那如何安全的给小表加字段？**

1. **解决长事务**，事务不提交，就会一直占着MDL锁。在MySQL的infomation_schema库的innodb_trx表中，你可以查到当前执行中的事务。如果要你要做DDL（ Data Definition Language ）变更的表有长事务在执行，要考虑暂停DDL，或者kill掉这个长事务。
2. **在alter table语句设定等待时间**，因为如果变更的表是一个热点表，请求频繁，这时候kill掉可能未必管用。有一个理想的机制时在alter table语句里面设定等待时间，如果在这个指定等待时间里面能够能拿到MDL写锁最后，拿不到也不要阻塞后面的业务语句，先放弃。之后通过重试命令重复这个过程。

